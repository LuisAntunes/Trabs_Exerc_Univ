
% Comboio - [L, CarA, CarB]
% Agulha - baixo/cima
% Sendo A uma area qualquer, A = [Comboio, Carruagens no troco]
% estado - [ AreaA, AreaB, AreaC, AreaD ]

% ------------------------------- Exemplo ---------------------------------
% So encontra solucao com a pesquisa informada
exemplo1_EI([ [[], CarruagensA], [Comboio, CarruagensB, Agulha], [[],CarruagensC], [[],CarruagensD] ]):-
	Comboio = [l, car,car],
	Agulha = cima,
	CarruagensA = [],
	CarruagensB = [],
	CarruagensC = [],
	CarruagensD = [].

exemplo1_EF([ [[], CarruagensA], [[], CarruagensB, Agulha], [[],CarruagensC], [Comboio,CarruagensD]]):-
	Comboio= [l],
	Agulha= baixo,
	CarruagensA = [],
	CarruagensB = [car,car],
	CarruagensC = [],
	CarruagensD = [].

% ---------------------------------------------------------------------------

estado_inicial([ [[], CarruagensA], [Comboio, CarruagensB, Agulha], [[],CarruagensC], [[],CarruagensD] ]):-
	Comboio = [l, car,car],
	Agulha = cima,
	CarruagensA = [],
	CarruagensB = [],
	CarruagensC = [],
	CarruagensD = [].

estado_final([ [[], CarruagensA], [[], CarruagensB, Agulha], [[],CarruagensC], [Comboio,CarruagensD]]):-
	Comboio= [l],
	Agulha= baixo,
	CarruagensA = [],
	CarruagensB = [car,car],
	CarruagensC = [],
	CarruagensD = [].

% ------------------------------- OPERACOES ---------------------------------
op(EI, frente, EF, 1):-
	frente(EI, EF).

op(EI, tras, EF, 1):-
	tras(EI, EF).

op(EI, engatar_frente, EF, 1):-
	engatar(EI, frente, EF).

op(EI, engatar_tras, EF, 1):-
        engatar(EI, tras, EF).

op(EI, desengatar_frente, EF, 1):-
	desengatar(EI, EF, frente).

op(EI, desengatar_frente, EF, 1):-
	desengatar(EI, EF, tras).

op(EI, comutar_agulha, EF, 1):-
	comutar(EI, EF).

% ------------------------------- COMUTAR ----------------------------------
comutar([AreaA|[AreaB|Outras]], [AreaA|[NovaAreaB|Outras]]):-
	comutar_(AreaB, NovaAreaB).

comutar_([Comboio|[Carr,baixo|[]]], [Comboio|[Carr,cima|[]]]).
comutar_([Comboio|[Carr,cima|[]]], [Comboio|[Carr,baixo|[]]]).

% ------------------------------- ENGATAR ----------------------------------
engatar( [Area|T], Direccao, [[NovoComboio|[[]|T2]]|T]):-
	Area = [Comboio|[H|T2]],
        Comboio \= [],
	H \= [],
	engatar_(Comboio, H, NovoComboio, Direccao),!.

engatar( [H|T], Dir, [H|EF] ):-
	engatar( T, Dir, EF ).

engatar_(Comboio, Cars, NovoComboio, frente):-
	append(Comboio, Cars, NovoComboio).

engatar_(Comboio, Cars, NovoComboio, tras):-
	append(Cars, Comboio, NovoComboio).


% ------------------------------ DESENGATAR ----------------------------------
desengatar(EI, EF, Dir):-
	desengatar_(EI, EF, Dir).

desengatar_([Area|Outras], [[NovoComboio, Carruagens2|T]|Outras], frente):-
	Area = [Comboio|[Carruagens|T]],
	length(Comboio, Size),
	Size > 1, nth(1, Comboio, E), E \= l,
	remove_first_position(Comboio, NovoComboio, Carruagem),
	append(Carruagens, [Carruagem], Carruagens2).

desengatar_([Area|Outras], [[NovoComboio, Carruagens2|T]|Outras], tras):-
        Area = [Comboio|[Carruagens|T]],
        length(Comboio, Size),
        Size > 1, nth(Size, Comboio, E), E \= l,
        remove_last_position(Comboio, NovoComboio, Carruagem),
        append(Carruagens, [Carruagem], Carruagens2).

desengatar_([H|T], [H|EF], Dir):-
	desengatar_(T, EF, Dir).



% -------------------------------- FRENTE ------------------------------------
frente(EI, EF):-
	remove_from( P, EI, EI2, Comboio ),
	frente_(P, EI2, EF, Comboio).
% A -> B
frente_(1, EI, EF, Comboio):-
	is_cima(EI),
	insert_at(2, EI, EF, Comboio),!.
% A -> D
frente_(1, EI, EF, Comboio):-
	insert_at(4, EI, EF, Comboio),!.
% B -> C
frente_(2, EI, EF, Comboio):-
	insert_at(3, EI, EF, Comboio),!.
% D -> C
frente_(4, EI, EF, Comboio):-
	insert_at(3, EI, EF, Comboio).

% ---------------------------- ANDAR PARA TRAS ------------------------------
tras(EI, EF):-
	remove_from(P, EI, EI2, Comboio),
	tras_(P, EI2, EF, Comboio).
% C -> B
tras_(3, EI, EF, Comboio):-
	is_cima(EI),
	insert_at(2, EI, EF, Comboio),!.
% C -> D
tras_(3, EI, EF, Comboio):-
	insert_at(4, EI, EF, Comboio),!.
% B -> A
tras_(2, EI, EF, Comboio):-
	insert_at(1, EI, EF, Comboio),!.
% D -> A
tras_(4, EI, EF, Comboio):-
	insert_at(1, EI, EF, Comboio).

% -------------------------- FUNCOES AUXILIARES------------------------------

% O predicado is_cima(?EstadoInicial) Ã© true se a agulha esta virada para cima
is_cima(EI):-
	nth1(2, EI, Area),
	member(cima, Area).

% Dado um estado inicial insere o comboio na posicao P
% insert_at( ?Posicao, ?EstadoInicial, ?EstadoFinal, Comboio)
insert_at( P, EI, EF, Comboio):-
	insert_at( P, EI, EF, Comboio, 1).

insert_at(P, [Area|T], [[Comboio|T1]|T], Comboio, I):-
	P = I,
	Area = [_|T1].

insert_at(P, [Area|T], [Area|T2], Comboio, I):-
	I2 is I + 1,
	insert_at(P, T, T2, Comboio, I2).

% Remove o comboio da lista e devolve a posicao
% remove_from( ?Posicao,?AreasComOComboio, ?AreasSemOComboio, ?Comboio).
remove_from( P, Areas, NewAreas, Comboio ):-
	remove_from_(P, Areas, NewAreas, Comboio, 1).

remove_from_( P, [Area|T], [[[]|T1]|T], Comboio, I):-
	Area = [Comboio|T1],
	Comboio \= [],
	P = I.

remove_from_( P, [Area|T], [Area|T1], Comboio2, I):-
	Area = [Comboio|_],
	Comboio = [],
	I2 is I + 1,
	remove_from_( P, T, T1, Comboio2, I2).

remove_last_position([E], [], E).

remove_last_position([H|T], [H|T2], E):-
	remove_last_position(T, T2, E).


remove_first_position([H|T], T, H).

% Diz em que area esta o comboio
posicao_comboio(P, Areas):-
	posicao_(P, Areas, 1).

posicao_(P, [Area|T], I):-
	Area = [Comboio|_],
	Comboio \= [],
	P = I.
posicao_(P, [_|T], I):-
	I2 is I+1,
	posicao_(P, T, I2).


% --------------------------- HEURISTICA -------------------------------
% soma das duas heuristicas
h(E, V):-
	h1(E, V1),
	h2(E, V2),
	V is V2.%+V2.
% -------------------------- HEURISTICA 1 ------------------------------
% Calcula a distancia que o comboio esta da area no estado final
h1(E, C):-
	estado_final(EF),
	posicao_comboio(Y, EF),
	posicao_comboio(X, E),
	nth1(2, E, AreaB),
	nth1(3, AreaB, Agulha),
	c(X, Y, C, Agulha).

% Custo com a agulha para cima
% c(?Origem, ?Destino, ?Custo, ?Agulha).
c(1, 2, 1, cima).
c(1, 3, 2, cima).
c(1, 4, 2, cima).
c(3, 4, 2, cima).
c(3, 2, 1, cima).
c(2, 4, 3, cima).
% Nao interessa a posicao da agulha
c(X, X, 0, _).
c(4, 1, 1, _).
c(4, 3, 1, _).
c(2, 1, 1, _).
c(2, 3, 1, _).
c(1, 3, 2, _).
c(3, 1, 2, _).
% Custo com a agulha para baixo
c(1, 2, 2, baixo).
c(1, 3, 2, baixo).
c(1, 4, 1, baixo).
c(2, 4, 2, baixo).
c(3, 4, 1, baixo).
c(3, 2, 2, baixo).
c(4, 2, 3, baixo).

% -------------------------- HEURISTICA 2 ------------------------------
h2(E, C):-
	n_carruagens(E, L),
	sum_list(L, C1),
	
	num_carruagens_comboio(E, N1),
	estado_final(EF),
	num_carruagens_comboio(EF, N2),
	N3 is N1 - N2,
	modulo(N3, N4),
	C is C1 + N4.

h22(E, C):-
	estado_final(EF),
	num_carruagens_comboio(EF, NCF),
	num_carruagens_comboio(E, NCI),
	N is NCF - NCI,
	modulo(N, C).

modulo(X, Y):-
	X < 0,
	Y is -1*X.

modulo(X, Y):-
	X>=0,
	Y = X.

% ----------------------------------------------------------------------
list_sum([X], X).

list_sum([H|T], X):-
	X is H + X1,
	list_sum(T, X1).

n_carruagens(E, L):-
	estado_final(EF),
	n_carruagens(E, EF, L, 1).

n_carruagens(EC, EF, [N], I):-
        I = 4,
        nth1(I, EF, Area1),
        nth1(I, EC, Area2),
        nth1(2, Area1, Car1),
	nth1(2, Area2, Car2),
        length(Car1, N1),
        length(Car2, N2),
        N3 is N1 - N2,
        modulo(N3, N).

n_carruagens(EC, EF, [N|T], I):-
	I =<3,
	nth1(I, EF, Area1),
	nth1(I, EC, Area2),
	nth1(2, Area1, Car1),
	nth1(2, Area2, Car2),
	length(Car1, N1),
	length(Car2, N2),
	N3 is N1 - N2,
	modulo(N3, N),
	I2 is I + 1,
	n_carruagens(EC, EF, T, I2).


% ----------------------------------------------------------------------
num_carruagens_comboio(Areas, N):-
	remove_from( _, Areas, _, Comboio ),
	length(Comboio, N1), N is N1 -1.

% Devolve uma lista com o num de carruagens de carruagens de cada area
num_carruagens_areas([Area], [N]):-
	num_carruagens_area(Area, N).

num_carruagens_areas([Area|Outras], [N|N2]):-
	num_carruagens_area(Area, N),
	num_carruagens_areas(Outras, N2).

num_carruagens_area(Area, N):-
	nth1(2, Area, Carruagens),
	length(Carruagens, N).
